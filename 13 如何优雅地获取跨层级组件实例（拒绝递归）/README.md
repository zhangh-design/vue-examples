## 如何优雅地获取跨层级组件实例（拒绝递归）

> 前言：上节课我们讲了组件之间跨层级通信的一个问题，那这节课我们来讲解一下组件之间如何跨层级的获取组件实例。

我们先来看一下什么是组件实例：

组件渲染完成后都会生成一个实例就像你`new`一个对象那理想状态下你并不需要访问这个实例那我们只需要关注数据就可以了但是随着你的业务越来越复杂然后你难免需要访问到一个我们的`Vue`组件实例的一个情况，举个例子就样我们使用`Echarts`业界很知名的一个数据可视化的库，如果说我们要使用`Echarts`那我们就很难避免去不操作我们实例的情况，在比如我们需要一个`input`的节点然后手动去处理一个`focus`的状态那这时候我们依然也要去访问我们的实例，基于这种情况呢所以`Vue`预留了一个`api`方便我们去获取实例的一个`api`就是我们的`ref`，我们通过`this.$refs.xxx`就是我们起的这个名字给这个组件上面挂载的这个`ref`的名字就像我们下图中看到的`p`节点`ref="p"`还有我们的`child-component`的`ref="child"`我们都可以通过`this.$refs.xxx`来访问到这个实例，但是这里需要注意的一点就是说我们如果说是一个普通的元素相当于我们这个`p`节点我们是获取到的真实的dom元素，那如果说是我们的一个自定义组件那么获取到的就是这个组件的实例了。

![image](https://github.com/zhangh-design/vue-examples/blob/master/13%20%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E8%8E%B7%E5%8F%96%E8%B7%A8%E5%B1%82%E7%BA%A7%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B%EF%BC%88%E6%8B%92%E7%BB%9D%E9%80%92%E5%BD%92%EF%BC%89/1.jpg)

`this.$refs.xxx`我们可以很方便的获取到当前组件上下文的实例但是如果说我们要获取我们跨层级的一个组件的实例那就很不方便了，那如果说我们要获取父组件的那可能我们可以通过`this.$parent.$refs`去获取，获取子组件的可能会`this.$children.$refs`的层级的获取，但如果当你的层级多的时候像我们前面举的那个例子你可能十级二十级的去获取这样的组件实例的一个情况那就是很不方便了，就像我们的这种图我们的`A`组件要访问我们`E`组件的一个实例或者是我们的`F`要访问我们的`A`组件的一个实例这时候我们第一想法那可能就是通过递归的方式来`E`节点然后一直的层级往上找它的一个`parent`然后一层层的去找通过递归的这个方式去查找我们的一个目标实例，的确有人是这么干的也有一些知名的开源的项目也有些是使用这种方式去做的但这种递归的方式啊它是非常繁琐代码也非常繁琐包括性能也是非常的低效而且每次你访问实例的时候你都要去走一遍这样的一个递归的形式因为你的实例是不能去被缓存的然而你底层的一个子组件实例如果被更新了你父组件是并不能及时的知道它这个实例是更新了，所以说你每次去使用的时候可能都需要去这样的一个层级的获取因为你没有办法去缓存，那针对这样的一个情况我们设计了一个更加高效的方案那如果你熟悉`react`可能会知道`react`的`ref`它是一个`callback`回调的一个形式这样的话我们在回调中就可以做很多的一个事情它就比较灵活了，针对这个回调灵活的特点然后我们可以设计了一种主动通知我这里写的一个`setXxxRef`这个`Xxx`到时候就是你起的名字至于你要不要用`set`也无所谓
只是说为了大家方便好理解，那还有一个主动通知（setXxxRef）、主动获取（getXxxRef）这样的一个方案就假如`A`要获取`E`的一个实例那`A`只要提供一个钩子函数`E`实例生成生产或者是更新之后主动的去调用这个钩子函数来通知`A`节点好我这个实例已经生成好了或者说我这个实例有更新我只需要告诉这个`A`节点而`A`节点将这个实例进行缓存就可以了它每次`A`节点需要访问的时候它总是能拿到更新的因为`E`节点更新之后它已经主动的告诉了`A`节点，是这样的一个形式那如何实现我们`callback`的一个`ref`然后就成了我们新的一个难点。


![image](https://github.com/zhangh-design/vue-examples/blob/master/13%20%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E8%8E%B7%E5%8F%96%E8%B7%A8%E5%B1%82%E7%BA%A7%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B%EF%BC%88%E6%8B%92%E7%BB%9D%E9%80%92%E5%BD%92%EF%BC%89/2.jpg)

![image](https://github.com/zhangh-design/vue-examples/blob/master/13%20%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E8%8E%B7%E5%8F%96%E8%B7%A8%E5%B1%82%E7%BA%A7%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B%EF%BC%88%E6%8B%92%E7%BB%9D%E9%80%92%E5%BD%92%EF%BC%89/3.jpg)


我们可以看一下我们的demo还是那个和我们上一节讲的整个结构还是一致的就是`A`节点下面有`B`、`C`这整个都是一样的我们通过这个`获取E h3 Ref`的`button`我们可以获取底层的`H节点`的一个`ref`然后我们点击很容易的就获取到了，那点击页面上的`获取A Ref`的`button`这样`F`节点可以跨层级的获取到它的祖先节点的一个`ref`，那点击`获取H Ref`的`button`这样`F`节点也一样它就是这样子的一个兄弟节点，我们可以看一下我们的图`H`节点和`F`节点其实它们之间已经属于不太很亲密的一个节点了。


![image](https://github.com/zhangh-design/vue-examples/blob/master/13%20%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E8%8E%B7%E5%8F%96%E8%B7%A8%E5%B1%82%E7%BA%A7%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B%EF%BC%88%E6%8B%92%E7%BB%9D%E9%80%92%E5%BD%92%EF%BC%89/4.jpg)


好了那我们看下我们的代码是怎么实现的那我们的`A`节点就是通过我们上节课讲的`provide`提供了这样一个主动通知还有主动获取的几个钩子函数我们的`setChildrenRef`然后我下面调取的时候我会把这个传递过来的这个`ref`进行缓存，`getChildrenRef`的话就是直接去获取我需要去获取的这个`name`的`ref`，我的子节点如何去调用我的这个`setChildrenRef`那就是通过`inject`然后把它注入，注入进来之后然后我通过`v-ant-ref`的形式，然后通过这样一个指令这个指令是我们自己去开发的然后就是把它变成了一个回调的形式每次我们的这个`ChildrenH`更新的时候或者是实例化完成的时候都会调用这个我们的回调去主动的通知到我们的上层的一个节点去告诉它我节点更新了，那为什么叫`v-ant-ref`因为之前在`Vue`的1.0的版本
实际上是有`v-ref`这样一个指令的但它做的事情完全不一样所以说我们很是担心就是说后续`Vue`官方会不会提供这样的一个钩子指令所以说我们暂且不使用这样的一个指令那万一以后它官方提供了会给我们产生一些冲突，那我们现在这个`v-ant-ref`的这样一个代码其实就是我们的一个自定义指令我们通过`bind`绑定的时候然后把我们的实例调用这个回调传递过去，但是更新的时候同样我们更新之后把这个新的一个实例去主动的告诉我们的上层的一个节点，其它的节点`E`节点和`F`节点也一样跨层级的时候我只要`inject`注入我的`getParentChildrenRef`这个名字你可以随便取这样的一个形式。

`A`节点，ChildA.vue

```
import ChildrenD from './ChildrenD';
export default{
    components: {
        ChildrenD
    },
    provide () {
        return {
          setChildrenRef: (name, ref) => {
            this[name] = ref;
          },
          getChildrenRef: name => {
            return this[name];
          },
          getRef: () => {
            return this;
          }
        }
    }
}
```

`D`节点，ChildD.vue

```
<template>
    <div>
    <ChildrenH v-ant-ref="c => setChildrenRef('childrenH', c)" />
    </div>
</template>

import ChildrenH from './ChildrenH';
export default {
    components: {
    ChildrenH
  },
  inject: {
    setChildrenRef: {
      default: () => {}
    }
  }
}
```

#### 结语：

好这就是我们说的如何优雅的去获取我们跨层级的一个组件我们避免了我们的回调不使用回调这样一个形式而且我们可以充分利用我们的一个缓存机制多次去避免你去执行递归的方式这样性能非常的一个底下
