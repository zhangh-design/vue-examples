## 理解虚拟DOM及key属性的作用

> 前言：这节课我们来聊聊虚拟DOM和key属性，我们先来了解下`JQuery`在`React`，`Angular`，`Vue`之前基本上前端是`JQuery`统治的天下直到现在依然有很多的系统还在使用`JQuery`进行开发它帮助我们简化了操作DOM的api，我们可以很方便的通过`JQuery`绑定事件然后通过事件来操作我们的`DOM`，但是随着我们的系统越来越复杂那事件也会变的越来越多不同的事件操作不同的`DOM`或者是相同的`DOM`那变的越来越乱每一次开发迭代的时候越来越小心翼翼可以说是因为这个痛点造就了`React`
和`Vue`的诞生，虽然我们的课程是`Vue`的课程不过这块内容的话`Vue`和`React`没有太大的区别那它们都是通过引入一个 数据的中间层  来避免我们直接操作我们的`DOM`那在`Vue`中我们不再关注我们的`DOM`元素而我们需要关注的仅仅是我们的数据`state`所有的事件我们最后操作的对象都应该是我们的数据然后由`Vue`底层来将数据映射到我们的`DOM`上那数据的变化会导致`DOM`的更新而`DOM`的更新变动也会非常耗性能的影响用户体验的而当数据变化后如何尽可能减少我们的`DOM`更新这就是形成了一个新的难题那这时候 虚拟DOM 的概念就被提了出来那我们的数据不是直接反应到真实的`DOM`节点上而是先通过数据和我们的模板生成一个类似`DOM`树的一个结构其实就是一个树结构一个body下面有div有span有p标签其实就是一个树结构但是这个树结构不是真实的`DOM`结构而是通过我们的一个类似`JSON`对象来去保留我们这样一个树形结构的信息那这个`DOM`树的话我们就称之为`虚拟DOM`然后我们经过一定的算法机制来计算出我们`老的DOM树`和我们即将要更新的`DOM树`也就是我们新的DOM树最终我们要改变哪些`DOM`然后我们通过算法来计算出来我们要改变的真实`DOM`通过算法尽可能的复用我们已有的`DOM`减少我们因为`DOM`而带来的性能消耗这样就涉及到了我们两棵DOM树的比对就是我们前一个老的`DOM树`和我们新的`DOM树`它们之间比对我们要查找出来它们之间的差异正常情况下如果按照我们一个正常的比对算法的话那时间复杂对就是`On3`的复杂度那这个复杂度的性能是低的但是考虑到我们前端页面的一个结构的特殊性那我们通常情况下不太会出现跨层级节点的一个移动例如：我们body下面一个div，div下面是一个span那我们这个span大部分的情况下不会说我就更新到了body下面和原来的div成了同一节点当然它也是有可能存在的当我们基于这种假设我们就做出了这样一种比对的算法就是我们只对同层级的节点进行比较就像我们下面（4）图里面画的一样同颜色区域内的进行比较那第一层的进行比较第二层的进行比较而同层中画的橙色的和橙色进行比较蓝色的和蓝色的进行比较那这样我们的时间复杂度就降到了我们的`On1`的复杂度那其实就是把我们所有的`DOM`节点遍历一遍基本上是这样的一种情况。

1.事件操作`DOM`：
![image](https://raw.githubusercontent.com/zhangh-design/vue-examples/master/07%20%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9FDOM%E5%8F%8Akey%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%9C%E7%94%A8/1.png)

2.系统越来越复杂后事件操作`DOM`:
![image](https://raw.githubusercontent.com/zhangh-design/vue-examples/master/07%20%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9FDOM%E5%8F%8Akey%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%9C%E7%94%A8/2.png)

3.Vue事件，中间层state，DOM元素：
![image](https://raw.githubusercontent.com/zhangh-design/vue-examples/master/07%20%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9FDOM%E5%8F%8Akey%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%9C%E7%94%A8/4.png)

4.两棵DOM树的比对：
![image](https://raw.githubusercontent.com/zhangh-design/vue-examples/master/07%20%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9FDOM%E5%8F%8Akey%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%9C%E7%94%A8/5.png)


那接下来我们通过几个场景来进一步加深理解：

有下面两棵`DOM`树，A的子节点B、C、D那直接变成我们的C、D、B这样的一个节点那映射到我们的`DOM`树的话是这样一种结构就是我们的div代表着我们的A节点就我们图中画的div下面第一个是div第二个是p第三个是span，那p标签下面又有我们的i标签和span标签就是我们图中所画的E和F实际上表达的意思就是说我们同级节点没有相同类型的第一层节点就是我们的根节点只有一个div第二级节点一个div一个p一个span我们用B、C、D来表示就是代表着我们同级节点没有相同类型的节点第三层是我们的E、F一样是一个i和一个span最终我们要把它变成我们2图右侧的这种形式就是把我们的p和我们的这个div做一个交换，交换位置，那么又再次回到我们这个1的图形那我们的目标是把C放到了B前面但是具体指明移动那我们是直接把我们的这个B节点直接移动到我们的D节点后面呢？这样移动完之后就变成了C、D、E那和我们要的一个结构是一样的还是说先移动C放到了B前面然后在移动我们的D放到了我们的B前面那同样也能达到我们的C、D、E这样的一个效果那具体是怎么移动的呢其实这个我们不用太多的关注这个移动的路径

1.dom树的理解图：
![image](https://raw.githubusercontent.com/zhangh-design/vue-examples/master/07%20%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9FDOM%E5%8F%8Akey%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%9C%E7%94%A8/6.png)

2.映射到我们的`DOM`树的结构：

![image](https://raw.githubusercontent.com/zhangh-design/vue-examples/master/07%20%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9FDOM%E5%8F%8Akey%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%9C%E7%94%A8/7.png)








